<?php
class LsTree{
    # directory and file mark
    private $_dirMark='d';
    private $_fileMark='f';
    private $_markLeftDelimiter='(';
    private $_markRightDelimiter=')';
    private $_fileSuffix='(f)';  # $_markLeftDelimiter . $_fileMark . $_markRightDelimiter
    private $_dirSuffix='(d)';  # $_markLeftDelimiter . $_dirMark . $_markRightDelimiter
    
    # html mode(default html mode is turn on)
    private $_HTMLMode=true;  # html mode means the output content format is html document, false will pure text
    private $_nl='<br/>';  # html mode => $_nl is '<br/>, non-html mode => $_nl is '\n'
    private $_space='&nbsp;';  # html mode => $_space is '&nbsp;', non-html mode => $_space is ' '
    
    # tree component
    private $_branch='|';
    private $_linkChar='-';
    private $_linkNum=4;
    private $_ramification='|----';  # $_branch + str_repeat($_linkChar, $_linkNum)
    private $_fillSpaces='&nbsp;&nbsp;&nbsp;&nbsp';  # str_repeat($_space, $_linkNum)
    
    private $_str='';  # hold the parsed content
    
    # utils
    private $_allowedDelimiter="'\"&<[({})]>&\"'";  # only those chars can be used as file type delimiter,must symmetry
    private $_entitiesMap=array('<'=>'&lt;','>'=>'&gt;','&'=>'&amp;','"'=>'&quot;',"'"=>'&#039;');
    
    
    # update 
    #    $_ramification, default is '|----'
    #    $_fillSpaces, default is '    ' or '&nbsp;&nbsp;&nbsp;&nbsp'
    #    $_dirSuffix, default is '(d)'
    #    $_fileSuffix, default is '(f)'
    private function _fix(){
        $this->_ramification=$this->_branch.str_repeat($this->_linkChar, $this->_linkNum);
        $this->_fillSpaces=str_repeat($this->_space, $this->_linkNum);
        $this->_dirSuffix=$this->_markLeftDelimiter.$this->_dirMark.$this->_markRightDelimiter;
        $this->_fileSuffix=$this->_markLeftDelimiter.$this->_fileMark.$this->_markRightDelimiter;
    }
    
    # recursive walk through $dir dump as a array
    private function _rd($dir){
        $stack=array();
        if($hd=@opendir($dir)){
            while($item=readdir($hd)){
                if($item=='.' || $item=='..')continue;
                $itemPath=join(DIRECTORY_SEPARATOR, array($dir, $item));
                if(is_dir($itemPath)){
                    array_push($stack, array('name'=>$item,'children'=>array()));
                    $stack[count($stack)-1]['children']=$this->_rd($itemPath);
                }
                else{
                    array_push($stack, array('name'=>$item));
                }
            }
        }
        closedir($hd);
        return $stack;
    }
    
    # parse the array(hold directory info, generated by $this->_rd())
    private function _parseArray($arr,$prefix=''){
        $str='';
        $len=count($arr);
        for($i=0;$i<$len;$i++){
            $item=$arr[$i];
            if(isset($item['children'])){
                $str.=$prefix.$this->_ramification.$item['name'].$this->_dirSuffix.$this->_nl;
                if(!empty($item['children'])){
                    if(!isset($arr[$i+1])){//whether have siblings
                        $temp=$prefix.$this->_branch.$this->_fillSpaces;
                        $index=strrpos($temp, $this->_branch);
                        if($index!==false){
                            $temp=substr($temp, 0,$index).$this->_space.substr($temp, $index+strlen($this->_branch));
                        }
                    }
                    else{
                        $temp=$prefix.$this->_branch.$this->_fillSpaces;
                    }
                   $str.=$this->_parseArray($item['children'],$temp);
                }
            }
            else{
                $str.=$prefix.$this->_ramification.$item['name'].$this->_fileSuffix.$this->_nl;
                //if($i==$len-1)$str.=$prefix.$this->_nl;//for pretty look
            }
            if($i==$len-1)$str.=$prefix.$this->_nl;//for pretty look
        }
        return $str;
    }

    
    # set directory and file mark
    public function setDirMark($mark){
        $this->_dirMark=$mark;
    }
    
    public function setFileMark($mark){
        $this->_fileMark=$mark;
    }
    
    # just specify left or right delimiter will set both
    public function setDelimiterMark($delimiter){
        $delimiter=$delimiter[0];
        $allowed=$this->_allowedDelimiter;
        $len=strlen($allowed);
        $index=strpos($allowed,$delimiter);
        if($index!==false){  # $index may be zero
            # convert ', ", <, > to entities char when html mode is turn on
            if($this->_HTMLMode && array_key_exists($delimiter, $this->_entitiesMap)){
                if($delimiter=='<'||$delimiter=='>'){  # > or <
                    $this->_markLeftDelimiter='&lt;';
                    $this->_markRightDelimiter='&gt;';
                }
                else{  # ' or "
                    $this->_markRightDelimiter=$this->_markLeftDelimiter=$this->_entitiesMap[$allowed[$index]];
                }
            }
            else{
                $this->_markLeftDelimiter=$allowed[min($index, $len-$index-1)];
                $this->_markRightDelimiter=$allowed[max($index, $len-$index-1)];
            }
            return true;
        }
        return false;
    }
    
    
    # turn on/off html mode
    public function setMode($mode){
        $mode=strtolower($mode);
        if($mode[0]=='h'){
            $this->_HTMLMode=true;
            $this->_nl='<br/>';
            $this->_space='&nbsp;';
            return true;
        }
        else if($mode[0]=='t'){
            $this->_HTMLMode=false;
            $this->_nl="\n";
            $this->_space=' ';
            return true;
        }
        return false;
    }
    
    
    # tree component
    public function setLinkNum($num){
        if(is_numeric($num)){
            $num=(int)abs($num);
            if($num>1){
                $this->_linkNum=$num;
                return true;
            }
        }
        return false;
    }
    
    public function setLinkChar($char){
        $char=$char[0];
        $this->_linkChar=$char;
    }
    
    
    # generate directory tree info into $this->_str
    public function ls($dir){
        if(!is_dir($dir))throw new Exception("ls arg:{$dir} is not a directory.");
        # before work, make all set*() effect
        $this->_fix();
        # root directory
        $this->_str=realpath($dir).$this->_dirSuffix.$this->_nl;
        # recursive parse directory
        $dirarray=$this->_rd($dir);
        # convert directory array to tree
        $this->_str.=$this->_parseArray($dirarray);
    }
    
    # print tree as html(or text) string or write tree into a file
    public function render($filename){
        if($this->_HTMLMode){
            echo '<meta charset="utf-8"/>';
            echo '<pre class="prettyprint">';
            echo $this->_str;
            echo '</pre>';
        }
        else{
            if(is_file($filename) && is_writable($filename)){
                $fh=fopen($filename, 'a+');
                fwrite($fh, $this->_str);
                fclose($fh);
            }
            else{
                echo $this->_str;
            }
        }
    }
    
    public function _test(){
        $this->_fix();
        echo $this->_linkNum.'<br/>';
        echo $this->_linkChar.'<br/>';
        echo $this->_fileSuffix.'<br/>';
        echo $this->_dirSuffix.'<br/>';
        echo $this->_ramification.'<br/>';
        echo $this->_branch.'<br/>';
        echo $this->_fileMark.'<br/>';
        echo $this->_dirMark.'<br/>';
        echo $this->_markLeftDelimiter.'<br/>';
        echo $this->_markRightDelimiter.'<br/>';
        echo $this->_str.'<br/>';
        echo '<pre>';
        print_r($this->_rd('.'));
        echo '</pre>';
    }
}
 $my=new LsTree('.');
// //$my->setMode('text');
// //$my->setMode('html');
// $my->setLinkNum(4);
// $my->setLinkChar('-');
// $my->setFileMark('f');
// $my->setDirMark('d');
// $my->setDelimiterMark('[');
// //$my->test();
 $my->ls('.');
 $my->render();
?>
